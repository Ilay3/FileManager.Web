<div id="accessModal" class="modal modal-exit" style="display:none;">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Настройки доступа</h3>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>Пользователи</label>
                <input type="text" id="userSearch" class="form-control" placeholder="Поиск пользователя">
                <div id="usersList" class="checkbox-list"></div>
            </div>
            <div class="form-group">
                <label>Группы</label>
                <input type="text" id="groupSearch" class="form-control" placeholder="Поиск группы">
                <div id="groupsList" class="checkbox-list"></div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="btn btn-secondary" onclick="closeAccessModal()">Отмена</button>
            <button class="btn btn-primary" onclick="submitAccess()">Сохранить</button>
        </div>
    </div>
</div>

<script>

    var accessTarget = window.accessTarget || { id: null, isFolder: true };
    window.accessTarget = accessTarget;
    var currentAccess = window.currentAccess || [];
    window.currentAccess = currentAccess;
    var ownerId = null;

    async function openAccessModal(targetId, isFolder) {
        accessTarget = { id: targetId, isFolder: isFolder };
        const modal = document.getElementById('accessModal');
        modal.style.display = 'flex';
        setTimeout(() => {
            modal.classList.remove('modal-exit');
            modal.classList.add('modal-enter');
        }, 10);
        await loadAccessLists();
        await loadCurrentAccess();
    }

    function closeAccessModal() {
        const modal = document.getElementById('accessModal');
        modal.classList.remove('modal-enter');
        modal.classList.add('modal-exit');
        setTimeout(() => {
            modal.style.display = 'none';
        }, 300);
    }

    async function loadAccessLists() {
        const ownerRes = accessTarget.isFolder
            ? await fetchWithProgress(`/api/folders/${accessTarget.id}`, { credentials: 'include' })
            : await fetchWithProgress(`/api/files/${accessTarget.id}`, { credentials: 'include' });
        if (ownerRes.ok) {
            const data = await ownerRes.json();
            ownerId = accessTarget.isFolder ? data.createdById : data.uploadedById;
        }

        const usersRes = await fetchWithProgress(`/api/users${ownerId ? `?ownerId=${ownerId}` : ''}`, { credentials: 'include' });
        const groupsRes = await fetchWithProgress('/api/groups', { credentials: 'include' });
        const users = usersRes.ok ? await usersRes.json() : [];
        users.sort((a, b) => a.fullName.localeCompare(b.fullName, 'ru'));
        const groups = groupsRes.ok ? await groupsRes.json() : [];
        groups.sort((a, b) => a.name.localeCompare(b.name, 'ru'));

        const usersList = document.getElementById('usersList');
        usersList.innerHTML = '';
        users.forEach(u => {
            if (ownerId && u.id === ownerId) return;
            const label = document.createElement('label');
            label.className = 'checkbox-item';
            label.innerHTML = `<input type="checkbox" class="access-user" value="${u.id}"> ${u.fullName}`;
            usersList.appendChild(label);
        });

        const groupsList = document.getElementById('groupsList');
        groupsList.innerHTML = '';
        groups.forEach(g => {
            const label = document.createElement('label');
            label.className = 'checkbox-item';
            label.innerHTML = `<input type="checkbox" class="access-group" value="${g.id}"> ${g.name}`;
            groupsList.appendChild(label);
        });
    }

    async function loadCurrentAccess() {
        const url = accessTarget.isFolder
            ? `/api/access/folder/${accessTarget.id}`
            : `/api/access/file/${accessTarget.id}`;
        const res = await fetchWithProgress(url, { credentials: 'include' });
        currentAccess = res.ok ? await res.json() : [];

        currentAccess.forEach(r => {
            if (r.userId) {
                const cb = document.querySelector(`.access-user[value="${r.userId}"]`);
                if (cb) {
                    cb.checked = true;
                    cb.dataset.ruleId = r.id;
                }
            }
            if (r.groupId) {
                const cb = document.querySelector(`.access-group[value="${r.groupId}"]`);
                if (cb) {
                    cb.checked = true;
                    cb.dataset.ruleId = r.id;
                }
            }
        });
    }

    function filterAccessList(searchId, listId) {
        const term = document.getElementById(searchId).value.toLowerCase();
        document.querySelectorAll(`#${listId} .checkbox-item`).forEach(item => {
            item.style.display = item.textContent.toLowerCase().includes(term) ? '' : 'none';
        });
    }

    document.getElementById('userSearch').addEventListener('input', () => filterAccessList('userSearch', 'usersList'));
    document.getElementById('groupSearch').addEventListener('input', () => filterAccessList('groupSearch', 'groupsList'));

    async function submitAccess() {
        const userCheckboxes = Array.from(document.querySelectorAll('.access-user'));
        const groupCheckboxes = Array.from(document.querySelectorAll('.access-group'));
        const toGrant = [];
        const toRevoke = [];

        userCheckboxes.forEach(cb => {
            if (cb.checked) {
                if (!cb.dataset.ruleId) {
                    toGrant.push({
                        fileId: accessTarget.isFolder ? null : accessTarget.id,
                        folderId: accessTarget.isFolder ? accessTarget.id : null,
                        userId: cb.value,
                        groupId: null,
                        accessType: 1,
                        inherit: true
                    });
                }
            } else if (cb.dataset.ruleId) {
                toRevoke.push(cb.dataset.ruleId);
            }
        });

        groupCheckboxes.forEach(cb => {
            if (cb.checked) {
                if (!cb.dataset.ruleId) {
                    toGrant.push({
                        fileId: accessTarget.isFolder ? null : accessTarget.id,
                        folderId: accessTarget.isFolder ? accessTarget.id : null,
                        userId: null,
                        groupId: cb.value,
                        accessType: 1,
                        inherit: true
                    });
                }
            } else if (cb.dataset.ruleId) {
                toRevoke.push(cb.dataset.ruleId);
            }
        });

        if (toGrant.length > 0) {
            const res = await fetchWithProgress('/api/access/bulk-grant', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ rules: toGrant }),
                credentials: 'include'
            });
            if (!res.ok) {
                const errorText = await res.text();
                console.error(errorText);
                if (res.status === 401 || res.status === 403) {
                    alert('Необходимо авторизоваться');
                } else {
                    alert(`Ошибка сохранения прав доступа: ${errorText}`);
                }
            }
        }

        for (const id of toRevoke) {
            const res = await fetchWithProgress(`/api/access/${id}`, { method: 'DELETE', credentials: 'include' });
            if (!res.ok) {
                const errorText = await res.text();
                console.error(errorText);
                if (res.status === 401 || res.status === 403) {
                    alert('Необходимо авторизоваться');
                    break;
                } else {
                    alert(`Ошибка удаления прав доступа: ${errorText}`);
                }
            }
        }

        closeAccessModal();
        if (window.showNotification) {
            showNotification('Права доступа обновлены', 'success');
        }
    }
</script>
